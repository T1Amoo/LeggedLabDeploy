# Copyright (c) 2022-2025, The unitree_rl_gym Project Developers.
# All rights reserved.
# Original code is licensed under BSD-3-Clause.
#
# Copyright (c) 2025-2026, The Legged Lab Project Developers.
# All rights reserved.
# Modifications are licensed under BSD-3-Clause.
#
# This file contains code derived from unitree_rl_gym Project (BSD-3-Clause license)
# with modifications by Legged Lab Project (BSD-3-Clause license).

"""
Hybrid Deployment Controller for Unitree Robots

This module implements a hybrid control system where:
- Upper body (arms, torso) movements are played from CSV trajectory files
- Lower body (legs) movements are generated by a trained policy network

The controller supports both G1 and H1 robot configurations.
Upper body trajectories are interpolated and synchronized with the control loop.
"""

import sys
import time
import csv
import os
from threading import Lock
from typing import List, Tuple, Optional

import numpy as np
import torch
from unitree_sdk2py.core.channel import (
    ChannelFactoryInitialize,
    ChannelPublisher,
    ChannelSubscriber,
)
from unitree_sdk2py.idl.default import (
    unitree_go_msg_dds__LowCmd_,
    unitree_go_msg_dds__LowState_,
    unitree_hg_msg_dds__LowCmd_,
    unitree_hg_msg_dds__LowState_,
)
from unitree_sdk2py.idl.unitree_go.msg.dds_ import LowCmd_ as LowCmdGo
from unitree_sdk2py.idl.unitree_go.msg.dds_ import LowState_ as LowStateGo
from unitree_sdk2py.idl.unitree_hg.msg.dds_ import LowCmd_ as LowCmdHG
from unitree_sdk2py.idl.unitree_hg.msg.dds_ import LowState_ as LowStateHG
from unitree_sdk2py.utils.crc import CRC
from unitree_sdk2py.utils.thread import RecurrentThread

from common.command_helper import (
    MotorMode,
    create_damping_cmd,
    init_cmd_go,
    init_cmd_hg,
)
from common.remote_controller import KeyMap, RemoteController
from common.rotation_helper import get_gravity_orientation, transform_imu_data
from config import Config


class TrajectoryPlayer:
    """
    Handles loading and playing of CSV trajectory files for upper body movements.
    
    Attributes:
        trajectory_data (np.ndarray): Loaded trajectory data
        current_frame (int): Current frame index
        loop (bool): Whether to loop the trajectory
        frame_rate (float): Target frame rate for trajectory playback
    """
    
    def __init__(self, csv_path: str, loop: bool = True, frame_rate: float = 50.0):
        """
        Initialize trajectory player.
        
        Args:
            csv_path (str): Path to CSV file containing trajectory data
            loop (bool): Whether to loop the trajectory when reaching the end
            frame_rate (float): Target frame rate for trajectory playback
        """
        self.csv_path = csv_path
        self.loop = loop
        self.frame_rate = frame_rate
        self.trajectory_data = None
        self.current_frame = 0
        self.frame_time = 0.0
        self.last_update_time = time.time()
        
        self._load_trajectory()
    
    def _load_trajectory(self):
        """Load trajectory data from CSV file."""
        if not os.path.exists(self.csv_path):
            raise FileNotFoundError(f"Trajectory file not found: {self.csv_path}")
        
        try:
            with open(self.csv_path, 'r') as file:
                reader = csv.reader(file)
                # Skip header if present
                header = next(reader, None)
                if header and not self._is_numeric(header[0]):
                    # Header exists and is not numeric, skip it
                    pass
                else:
                    # No header or numeric header, reset file pointer
                    file.seek(0)
                    reader = csv.reader(file)
                
                data = []
                for row in reader:
                    if row and all(self._is_numeric(val) for val in row):
                        data.append([float(val) for val in row])
                
                if not data:
                    raise ValueError("No valid numeric data found in CSV file")
                
                self.trajectory_data = np.array(data, dtype=np.float32)
                print(f"Loaded trajectory with {len(self.trajectory_data)} frames and {self.trajectory_data.shape[1]} joints")
                
        except Exception as e:
            raise RuntimeError(f"Failed to load trajectory file: {e}")
    
    def _is_numeric(self, value: str) -> bool:
        """Check if a string value can be converted to float."""
        try:
            float(value)
            return True
        except ValueError:
            return False
    
    def get_current_targets(self, control_dt: float) -> np.ndarray:
        """
        Get current target joint positions for upper body.
        
        Args:
            control_dt (float): Control loop time step
            
        Returns:
            np.ndarray: Target joint positions for current frame
        """
        if self.trajectory_data is None:
            return None
        
        current_time = time.time()
        self.frame_time += current_time - self.last_update_time
        self.last_update_time = current_time
        
        # Calculate frame index based on time
        frame_idx = int(self.frame_time * self.frame_rate)
        
        if frame_idx >= len(self.trajectory_data):
            if self.loop:
                # Loop back to beginning
                frame_idx = frame_idx % len(self.trajectory_data)
                self.frame_time = frame_idx / self.frame_rate
            else:
                # Stay at last frame
                frame_idx = len(self.trajectory_data) - 1
        
        self.current_frame = frame_idx
        return self.trajectory_data[frame_idx]
    
    def reset(self):
        """Reset trajectory player to beginning."""
        self.current_frame = 0
        self.frame_time = 0.0
        self.last_update_time = time.time()


class HybridController:
    """
    Hybrid controller that combines trajectory playback for upper body 
    and policy-based control for lower body.
    
    Attributes:
        config (Config): Robot configuration
        policy (torch.jit.ScriptModule): Trained policy network
        trajectory_player (TrajectoryPlayer): Upper body trajectory player
        upper_body_indices (List[int]): Indices of upper body joints
        lower_body_indices (List[int]): Indices of lower body joints
    """
    
    def __init__(self, config: Config, net: str, upper_body_csv: str, 
                 loop_trajectory: bool = True):
        """
        Initialize hybrid controller.
        
        Args:
            config (Config): Robot configuration
            net (str): Network interface name
            upper_body_csv (str): Path to CSV file for upper body trajectory
            loop_trajectory (bool): Whether to loop the trajectory
        """
        ChannelFactoryInitialize(0, net)

        self.first_run = True
        self.config = config
        self.remote_controller = RemoteController()
        
        # Initialize trajectory player for upper body
        self.trajectory_player = TrajectoryPlayer(upper_body_csv, loop=loop_trajectory)
        
        # Automatically identify upper and lower body joint indices based on robot type
        if config.msg_type == "hg":  # G1 robot
            # G1: joints 22-28 are upper body (arms), 0-21 are lower body (legs + waist)
            self.upper_body_indices = list(range(22, config.num_actions))
            self.lower_body_indices = list(range(0, 22))
        elif config.msg_type == "go":  # H1 robot
            # H1: joints 18-19 are upper body (arms), 0-17 are lower body (legs)
            self.upper_body_indices = list(range(18, config.num_actions))
            self.lower_body_indices = list(range(0, 18))
        else:
            raise ValueError("Invalid msg_type")
        
        print(f"Upper body joints: {self.upper_body_indices}")
        print(f"Lower body joints: {self.lower_body_indices}")

        # Load policy for lower body control
        self.policy = torch.jit.load(config.policy_path).eval()
        self.run_thread = RecurrentThread(interval=self.config.control_dt, target=self.run)
        self.publish_thread = RecurrentThread(interval=1 / 500, target=self.publish)
        self.cmd_lock = Lock()

        # Initialize state variables
        self.joint_pos = np.zeros(config.num_actions, dtype=np.float32)
        self.joint_vel = np.zeros(config.num_actions, dtype=np.float32)
        self.action = np.zeros(config.num_actions, dtype=np.float32)

        self.current_obs = np.zeros(config.num_obs, dtype=np.float32)
        self.current_obs_history = np.zeros((config.history_length, config.num_obs), dtype=np.float32)

        # Command clipping
        self.clip_min_command = np.array(
            [
                self.config.command_range["lin_vel_x"][0],
                self.config.command_range["lin_vel_y"][0],
                self.config.command_range["ang_vel_z"][0],
            ],
            dtype=np.float32,
        )
        self.clip_max_command = np.array(
            [
                self.config.command_range["lin_vel_x"][1],
                self.config.command_range["lin_vel_y"][1],
                self.config.command_range["ang_vel_z"][1],
            ],
            dtype=np.float32,
        )

        # Warm up policy
        for _ in range(50):
            with torch.inference_mode():
                obs = self.current_obs_history.reshape(1, -1).astype(np.float32)
                self.policy(torch.from_numpy(obs))

        # Initialize robot communication based on message type
        self._init_robot_communication()
        
        # Wait for robot connection and initialization
        self.wait_for_low_state()
        self._init_robot_commands()
        
        # Start control threads
        self.publish_thread.Start()
        self.wait_for_start()
        self.move_to_default_pos()
        self.wait_for_control()

        print("Start Hybrid Control!")
        print(f"Upper body: Trajectory playback from {upper_body_csv}")
        print(f"Lower body: Policy-based control")
        print(f"Robot type: {config.msg_type.upper()}")
        print(f"Upper body joints: {self.upper_body_indices}")
        print(f"Lower body joints: {self.lower_body_indices}")
        self.run_thread.Start()

    def _init_robot_communication(self):
        """Initialize robot communication channels based on message type."""
        if self.config.msg_type == "hg":
            self.low_cmd = unitree_hg_msg_dds__LowCmd_()
            self.low_state = unitree_hg_msg_dds__LowState_()
            self.mode_pr_ = MotorMode.PR

            self.lowcmd_publisher_ = ChannelPublisher(self.config.lowcmd_topic, LowCmdHG)
            self.lowcmd_publisher_.Init()

            self.lowstate_subscriber = ChannelSubscriber(self.config.lowstate_topic, LowStateHG)
            self.lowstate_subscriber.Init(self.LowStateHandler, 10)
        elif self.config.msg_type == "go":
            self.low_cmd = unitree_go_msg_dds__LowCmd_()
            self.low_state = unitree_go_msg_dds__LowState_()

            self.lowcmd_publisher_ = ChannelPublisher(self.config.lowcmd_topic, LowCmdGo)
            self.lowcmd_publisher_.Init()

            self.lowstate_subscriber = ChannelSubscriber(self.config.lowstate_topic, LowStateGo)
            self.lowstate_subscriber.Init(self.LowStateHandler, 10)
        else:
            raise ValueError("Invalid msg_type")

    def _init_robot_commands(self):
        """Initialize robot commands based on message type."""
        if self.config.msg_type == "hg":
            self.low_cmd = init_cmd_hg(self.low_cmd, self.mode_machine_, self.mode_pr_)
        elif self.config.msg_type == "go":
            self.low_cmd = init_cmd_go(self.low_cmd, weak_motor=self.config.weak_motor)

    def LowStateHandler(self, msg):
        """Handle incoming low state messages."""
        if self.config.msg_type == "hg":
            self.low_state = msg
            self.remote_controller.set(self.low_state.wireless_remote)
        else:
            self.low_state = msg
            self.remote_controller.set(self.low_state.wireless_remote)

    def publish(self):
        """Publish robot commands."""
        with self.cmd_lock:
            self.low_cmd.crc = CRC().Crc(self.low_cmd)
            self.lowcmd_publisher_.Write(self.low_cmd)

    def stop(self):
        """Stop controller and exit."""
        print("Select Button detected, Exit!")
        self.publish_thread.Wait()
        with self.cmd_lock:
            self.low_cmd = create_damping_cmd(self.low_cmd)
            self.low_cmd.crc = CRC().Crc(self.low_cmd)
            self.lowcmd_publisher_.Write(self.low_cmd)
        time.sleep(0.2)
        sys.exit(0)

    def wait_for_low_state(self):
        """Wait for robot connection."""
        while self.low_state.tick == 0:
            time.sleep(self.config.control_dt)
        if self.config.msg_type == "hg":
            self.mode_machine_ = self.low_state.mode_machine
        print("Successfully connected to the robot.")

    def wait_for_start(self):
        """Wait for start signal."""
        print("Enter zero torque state.")
        print("Waiting for the start signal to move to default pos...")
        while self.remote_controller.button[KeyMap.start] != 1:
            if self.remote_controller.button[KeyMap.select] == 1:
                self.stop()
            time.sleep(self.config.control_dt)

    def move_to_default_pos(self):
        """Move robot to default position."""
        print("Moving to default pos.")
        total_time = 2
        num_step = int(total_time / self.config.control_dt)

        dof_idx = self.config.joint2motor_idx
        dof_size = len(dof_idx)

        init_dof_pos = np.zeros(dof_size, dtype=np.float32)
        for i in range(dof_size):
            init_dof_pos[i] = self.low_state.motor_state[dof_idx[i]].q

        for i in range(num_step):
            if self.remote_controller.button[KeyMap.select] == 1:
                self.stop()
            alpha = i / num_step
            with self.cmd_lock:
                for j in range(dof_size):
                    motor_idx = dof_idx[j]
                    target_pos = self.config.default_joint_pos[j]
                    self.low_cmd.motor_cmd[motor_idx].q = init_dof_pos[j] * (1 - alpha) + target_pos * alpha
                    self.low_cmd.motor_cmd[motor_idx].dq = 0
                    self.low_cmd.motor_cmd[motor_idx].kp = self.config.kps[j]
                    self.low_cmd.motor_cmd[motor_idx].kd = self.config.kds[j]
                    self.low_cmd.motor_cmd[motor_idx].tau = 0
            time.sleep(self.config.control_dt)

    def wait_for_control(self):
        """Wait for control signal."""
        print("Enter default pos state.")
        print("Waiting for the Button A signal to Start Control...")
        while self.remote_controller.button[KeyMap.A] != 1:
            if self.remote_controller.button[KeyMap.select] == 1:
                self.stop()
            time.sleep(self.config.control_dt)

    def run(self):
        """Main control loop combining trajectory playback and policy control."""
        # Read current joint states
        for i in range(len(self.config.joint2motor_idx)):
            self.joint_pos[i] = self.low_state.motor_state[self.config.joint2motor_idx[i]].q
            self.joint_vel[i] = self.low_state.motor_state[self.config.joint2motor_idx[i]].dq

        # Process IMU data
        quat = self.low_state.imu_state.quaternion
        ang_vel = np.array([self.low_state.imu_state.gyroscope], dtype=np.float32)

        if self.config.imu_type == "torso":
            waist_yaw = self.low_state.motor_state[self.config.torso_idx].q
            waist_yaw_omega = self.low_state.motor_state[self.config.torso_idx].dq
            quat, ang_vel = transform_imu_data(
                waist_yaw=waist_yaw, waist_yaw_omega=waist_yaw_omega, imu_quat=quat, imu_omega=ang_vel
            )

        gravity_orientation = get_gravity_orientation(quat)
        joint_pos = (self.joint_pos - self.config.default_joint_pos) * self.config.dof_pos_scale
        joint_vel = self.joint_vel * self.config.dof_vel_scale
        ang_vel = ang_vel * self.config.ang_vel_scale

        # Process remote controller commands
        command = np.array(
            [self.remote_controller.ly, -self.remote_controller.lx, -self.remote_controller.rx], dtype=np.float32
        )
        command *= self.config.command_scale
        command = np.clip(command, self.clip_min_command, self.clip_max_command)

        # Prepare observation for policy (only lower body)
        num_actions = self.config.num_actions
        self.current_obs[:3] = ang_vel
        self.current_obs[3:6] = gravity_orientation
        self.current_obs[6:9] = command
        self.current_obs[9 : 9 + num_actions] = joint_pos
        self.current_obs[9 + num_actions : 9 + num_actions * 2] = joint_vel
        self.current_obs[9 + num_actions * 2 : 9 + num_actions * 3] = self.action

        # Update observation history
        if self.first_run:
            self.current_obs_history[:] = self.current_obs.reshape(1, -1)
            self.first_run = False
        else:
            self.current_obs_history = np.concatenate(
                (self.current_obs_history[1:], self.current_obs.reshape(1, -1)), axis=0
            )

        # Get policy action for lower body
        obs = self.current_obs_history.reshape(1, -1).astype(np.float32)
        policy_action = self.policy(torch.from_numpy(obs).clip(-100, 100)).clip(-100, 100).detach().numpy().squeeze()
        
        # Get trajectory targets for upper body
        upper_body_targets = self.trajectory_player.get_current_targets(self.config.control_dt)
        
        if upper_body_targets is None:
            print("Warning: No upper body trajectory data available")
            upper_body_targets = np.zeros(len(self.upper_body_indices))
        
        # Combine upper body trajectory and lower body policy
        self.action = np.zeros(num_actions, dtype=np.float32)
        
        # Set upper body actions from trajectory
        for i, joint_idx in enumerate(self.upper_body_indices):
            if i < len(upper_body_targets):
                self.action[joint_idx] = upper_body_targets[i]
        
        # Set lower body actions from policy
        for i, joint_idx in enumerate(self.lower_body_indices):
            if i < len(policy_action):
                self.action[joint_idx] = policy_action[i]

        # Calculate target positions
        target_dof_pos = self.config.default_joint_pos + self.action * self.config.action_scale
        
        # Send commands to robot
        with self.cmd_lock:
            for i in range(len(self.config.joint2motor_idx)):
                self.low_cmd.motor_cmd[self.config.joint2motor_idx[i]].q = target_dof_pos[i]


def main():
    """Main function to run the hybrid controller."""
    import argparse

    parser = argparse.ArgumentParser(description="Hybrid Controller: Upper body trajectory + Lower body policy")
    parser.add_argument("--net", type=str, default="eno1", help="Network interface")
    parser.add_argument("--config_path", type=str, default="configs/g1.yaml", help="Configuration file path")
    parser.add_argument("--upper_body_csv", type=str, required=True, 
                       help="Path to CSV file containing upper body trajectory")
    parser.add_argument("--loop_trajectory", action="store_true", default=True,
                       help="Whether to loop the trajectory")
    
    args = parser.parse_args()

    # Load configuration
    config = Config(args.config_path)
    
    # Create and run hybrid controller
    controller = HybridController(
        config=config,
        net=args.net,
        upper_body_csv=args.upper_body_csv,
        loop_trajectory=args.loop_trajectory
    )

    try:
        while True:
            if controller.remote_controller.button[KeyMap.select] == 1:
                print("Select Button detected, Exit!")
                break
            time.sleep(0.01)
    finally:
        controller.run_thread.Wait()
        controller.publish_thread.Wait()
        with controller.cmd_lock:
            controller.low_cmd = create_damping_cmd(controller.low_cmd)
            controller.low_cmd.crc = CRC().Crc(controller.low_cmd)
            controller.lowcmd_publisher_.Write(controller.low_cmd)
        time.sleep(0.2)
        print("Exit")


if __name__ == "__main__":
    main()
